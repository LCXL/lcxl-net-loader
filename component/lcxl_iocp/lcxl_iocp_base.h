#ifndef _LCXL_IOCP_BASE_H_

void inline OutputDebugStr(const TCHAR *DebugInfo) 
{
	OutputDebugString(DebugInfo);
}

#ifdef _DEBUG
#define RELEASE_INLINE
#else
#define RELEASE_INLINE inline
#endif // DEBUG


typedef enum _IocpEventEnum {ieAddSocket,

	/// <summary>
	/// socket从IOCP管理器移除事件
	/// </summary>
	ieDelSocket,

	/// <summary>
	/// socket被系统关闭事件，当触发这事件时，用户必须释放此socket的引用，以便iocp管理器清除此socket，当用户引用释放之后，会触发ieD
	/// elSocket事件
	/// </summary>
	ieCloseSocket,

	ieError,

	/// <summary>
	/// ieRecvPart 在本单元中没有实现，扩展用
	/// </summary>
	ieRecvPart,

	ieRecvAll,

	ieRecvFailed,

	ieSendPart,

	ieSendAll,

	ieSendFailed} IocpEventEnum, *PIocpEventEnum;
typedef enum _ListenEventEnum {leAddSockLst, leDelSockLst, leCloseSockLst, leListenFailed} ListenEventEnum, *PListenEventEnum;
//Socket类
class SocketBase;
// 监听socket类，要实现不同的功能，需要继承并实现其子类
class SocketLst;
//typedef IOCPOverlapped *PIOCPOverlapped;
class SocketObj;
class IOCPBaseList;
class IOCPManager;
typedef enum _OverlappedTypeEnum {otRecv, otSend, otListen} OverlappedTypeEnum;
/// <summary>
/// socket类的状态
/// </summary>
typedef enum _SocketInitStatus {
	/// <summary>
	/// socket类正在初始化
	/// </summary>
	sisInitializing,

	/// <summary>
	/// socket类初始化完成
	/// </summary>
	sisInitialized,

	/// <summary>
	/// socket类正在析构
	/// </summary>
	sisDestroying} SocketInitStatus;

typedef struct _IOCPOverlapped {
	OVERLAPPED lpOverlapped;
	WSABUF DataBuf;
	BOOL IsUsed;
	OverlappedTypeEnum OverlappedType;
	SocketBase AssignedSockObj;
	LPVOID GetRecvData();
	DWORD GetRecvDataLen();
	DWORD GetCurSendDataLen();
	LPVOID GetSendData();
	DWORD GetTotalSendDataLen();
	union
	{
		struct {
			LPVOID RecvData;
			DWORD RecvDataLen;

		};
		struct 
		{
			LPVOID SendData;
			LPVOID CurSendData;
			DWORD SendDataLen;
		};
		struct  
		{
			SOCKET AcceptSocket;
		};
	};
} IOCPOverlapped, *PIOCPOverlapped;

class SocketBase {
protected:
	int mRefCount;
	int mUserRefCount;
	SocketInitStatus mIniteStatus;
	SOCKET mSock;
	IOCPBaseList mOwner;
	HANDLE mIOComp;
	PIOCPOverlapped mAssignedOverlapped;
	UINT_PTR mTag;
	virtual BOOL Init() = 0;
	int InternalIncRefCount(int Count=1, BOOL UserMode=FALSE);
	int InternalDecRefCount(int Count=1, BOOL UserMode=FALSE);
public:
	SocketBase();
	~SocketBase();
	//Property
	IOCPBaseList GetOwner();
	SOCKET GetSocket();
	SocketInitStatus GetIniteStatus();
	UINT_PTR GetTag();
	void SetTag(UINT_PTR Value);
	int IncRefCount(int Count=1);
	int DecRefCount(int Count=1);
};

class SockLst: public SocketBase {
private:
	int mPort;
	LPVOID mLstBuf;
	DWORD mLstBufLen;
	int mSocketPoolSize;
	void SetSocketPoolSize(const int Value);
protected:
	BOOL Accept();
	virtual BOOL Init();
	virtual void CreateSockObj(SocketObj &SockObj);
public:
	SockLst();
	~SockLst();
	//Property
	int GetPort();
	int GetSocketPoolSize();
	void SetSocketPoolSize(int Value);
	BOOL StartListen(IOCPBaseList IOCPList, int Port, u_long InAddr = INADDR_ANY);
};

/// <summary>
/// Socket类，一个类管一个套接字
/// </summary>
class SocketObj: public SocketBase {
private:
	DWORD mRecvBufLen;
	LPVOID mRecvBuf;
	BOOL mIsSerSocket;
	BOOL mIsSending;
	vector<PIOCPOverlapped> mSendDataQueue;
	BOOL WSARecv();
	BOOL WSASend(PIOCPOverlapped Overlapped);
protected:
	virtual BOOL Init();
public:
	SocketObj();
	~SocketObj();
	/// <summary>
	/// 连接指定的网络地址，支持IPv6
	/// </summary>
	/// <param name="IOCPList">
	/// Socket列表
	/// </param>
	/// <param name="SerAddr">
	/// 要连接的地址
	/// </param>
	/// <param name="Port">
	/// 要连接的端口号
	/// </param>
	/// <param name="IncRefNumber">如果成功，则增加多少引用计数，引用计数需要程序员自己释放，不然会一直占用</param>
	/// <returns>
	/// 返回是否连接成功
	/// </returns>
	BOOL ConnectSer(IOCPBaseList IOCPList, const TCHAR *SerAddr, int Port, int IncRefNumber);
	//Windows平台下使用WSAAddressToString 
	BOOL GetRemoteAddr(_Inout_ LPTSTR AddressString, DWORD &AddressStringLength, WORD &Port);
	BOOL GetLocalAddr(_Inout_ LPTSTR AddressString, DWORD &AddressStringLength, WORD &Port);
	LPVOID GetRecvBuf();
	void SetRecvBufLenBeforeInit(DWORD NewRecvBufLen);
	BOOL SendData(LPVOID Data, DWORD DataLen, BOOL UseGetSendDataFunc = FALSE);
	LPVOID GetSendData(DWORD DataLen);
	void FreeSendData(LPVOID Data);
	void SetKeepAlive(BOOL IsOn, int KeepAliveTime = 50000, int KeepAliveInterval = 30000);
	BOOL IsSerSocket();
};

/// <summary>
/// 存储Socket列表的类，前身为的TSocketMgr类
/// </summary>
class IOCPBaseList{
private:
	HANDLE mCanDestroyEvent;
	BOOL mIsFreeing;
	IOCPManager *mOwner;
	int mLockRefNum;
	RTL_CRITICAL_SECTION mSockBaseCS;
	vector<SocketBase*> mSockBaseList;
	vector<SocketBase*> mSockBaseAddList;
	vector<SocketBase*> mSockBaseDelLis;
	vector<SocketObj*> mSockObjList;
	vector<SockLst*> mSockLstList;
	
protected:
	/// <summary>
	/// 这个只是单纯的临界区锁，要更加有效的锁定列表，使用 LockSockList
	/// </summary>
	RELEASE_INLINE void Lock();
	/// <summary>
	/// 添加sockobj到列表中，返回True表示成功，返回False表示失败，注意这里要处理IsFreeing为True的情况
	/// </summary>
	RELEASE_INLINE void Unlock();
	/// <summary>
	/// 添加sockobj到列表中，返回True表示成功，返回False表示失败，注意这里要处理IsFreeing为True的情况
	/// </summary>
	BOOL AddSockBase(SocketBase *SockBase);
	/// <summary>
	/// 移除sockbase，如果 列表被锁定，则将socket类放入待删除队列中
	/// </summary>
	BOOL RemoveSockBase(SocketBase *SockBase);
	/// <summary>
	/// 初始化SockBase
	/// </summary>
	BOOL InitSockBase(SocketBase *SockBase);
	/// <summary>
	/// 释放sockbase，并触发事件，此时sockbase必须已经从列表中移除
	/// </summary>
	BOOL FreeSockBase(SocketBase *SockBase);
	/// <summary>
	/// 在IOCP管理器中注册SockBase
	/// </summary>
	RELEASE_INLINE BOOL IOCPRegSockBase(SocketBase *SockBase);
	void WaitForDestroyEvent();
	/// <summary>
	/// 检查是否可以释放
	/// </summary>
	void CheckCanDestroy();
	/// <summary>
	/// IOCP事件
	/// </summary>
	virtual void OnIOCPEvent(IocpEventEnum EventType, SocketObj SockObj, PIOCPOverlapped Overlapped);
	virtual void OnListenEvent(ListenEventEnum EventType, SocketLst SockLst);
public:
	IOCPBaseList();
	~IOCPBaseList();
	/// <summary>
	/// 锁定列表，注意的锁定后不能对列表进行增加，删除操作，一切都由SocketMgr类维护
	/// </summary>
	void LockSockList();

	void UnlockSockList();
	/// <summary>
	/// 处理消息函数，在有窗口的程序下使用
	/// </summary>
	void ProcessMsgEvent();
	/// <summary>
	/// 关闭所有的Socket
	/// </summary>
	void CloseAllSockObj();
	/// <summary>
	/// 关闭所有的Socket，包括监听socket和非监听socket
	/// </summary>
	void CloseAllSockLst();

	/// <summary>
	/// 此类的拥有者
	/// </summary>
	IOCPManager *GetOwner();
	vector<SocketBase*> *GetSockBaseList();
	vector<SockLst*> *GetSockLstList();
	vector<SocketObj*> *GetSockObjList();
	/// <summary>
	/// 获取本机IP地址列表
	/// </summary>
	/// <param name="Addrs">
	/// 获取后的ip地址存入此列表中
	/// </param>
	static void GetLocalAddrs(vector<std::string> &Addrs);
};

class IOCPManager {
private:
	WSADATA mwsaData;
	vector<IOCPBaseList*> mSockList;
	RTL_CRITICAL_SECTION mSockListCS;
	vector<PIOCPOverlapped> mOverLappedList;
	RTL_CRITICAL_SECTION mOverLappedListCS;
	HANDLE mCompletionPort;
	vector<HANDLE> mIocpWorkThreads;
protected:
	void AddSockList(IOCPBaseList SockList);
	void RemoveSockList(IOCPBaseList SockList);
	void FreeOverLappedList();
	void DelOverlapped(PIOCPOverlapped UsedOverlapped);
	PIOCPOverlapped NewOverlapped(SocketBase *SockObj,OverlappedTypeEnum OverlappedType);
	BOOL PostExitStatus();
public:
	IOCPManager();
	~IOCPManager();
	RELEASE_INLINE void LockSockList();

	vector<IOCPBaseList*> *GetSockList();
	RELEASE_INLINE void UnlockSockList();
	RELEASE_INLINE void LockOverLappedList();
	vector<PIOCPOverlapped> *GetOverLappedList;
	RELEASE_INLINE void UnlockOverLappedList();
};

#endif